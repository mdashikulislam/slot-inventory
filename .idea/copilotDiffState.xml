<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/client/src/lib/store.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client/src/lib/store.tsx" />
              <option name="originalContent" value="import React, { createContext, useContext, useState, useEffect } from &quot;react&quot;;&#10;import { subDays, isAfter, parseISO } from &quot;date-fns&quot;;&#10;import { nanoid } from &quot;nanoid&quot;;&#10;&#10;// --- Types ---&#10;&#10;export interface Phone {&#10;  id: string;&#10;  phoneNumber: string;&#10;  email: string;&#10;  provider?: string;&#10;  remark?: string;&#10;  createdAt: string;&#10;}&#10;&#10;export interface IP {&#10;  id: string;&#10;  ipAddress: string;&#10;  port?: string;&#10;  username?: string;&#10;  password?: string;&#10;  provider?: string;&#10;  remark?: string;&#10;  createdAt: string;&#10;}&#10;&#10;export interface Slot {&#10;  id: string;&#10;  phoneId: string;&#10;  ipId: string;&#10;  count: number;&#10;  usedAt: string;&#10;}&#10;&#10;interface AppState {&#10;  phones: Phone[];&#10;  ips: IP[];&#10;  slots: Slot[];&#10;  isAuthenticated: boolean;&#10;}&#10;&#10;interface StoreContextType extends AppState {&#10;  addPhone: (phone: Omit&lt;Phone, &quot;id&quot; | &quot;createdAt&quot;&gt;) =&gt; void;&#10;  updatePhone: (id: string, phone: Partial&lt;Phone&gt;) =&gt; void;&#10;  deletePhone: (id: string) =&gt; void;&#10;  addIp: (ip: Omit&lt;IP, &quot;id&quot; | &quot;createdAt&quot;&gt;) =&gt; void;&#10;  updateIp: (id: string, ip: Partial&lt;IP&gt;) =&gt; void;&#10;  deleteIp: (id: string) =&gt; void;&#10;  addSlot: (phoneId: string, ipId: string, count: number, date: Date) =&gt; { success: boolean; error?: string };&#10;  deleteSlot: (id: string) =&gt; void;&#10;  getPhoneSlotUsage: (phoneId: string) =&gt; number;&#10;  getIpSlotUsage: (ipId: string) =&gt; number;&#10;  resetData: () =&gt; void;&#10;  login: () =&gt; void;&#10;  logout: () =&gt; void;&#10;}&#10;&#10;// --- Initial Data for Demo ---&#10;&#10;const INITIAL_STATE: AppState = {&#10;  phones: [&#10;    { id: &quot;p1&quot;, phoneNumber: &quot;+15550101&quot;, email: &quot;demo1@example.com&quot;, provider: &quot;Verizon&quot;, remark: &quot;Primary demo phone&quot;, createdAt: new Date().toISOString() },&#10;    { id: &quot;p2&quot;, phoneNumber: &quot;+15550102&quot;, email: &quot;demo2@example.com&quot;, provider: &quot;AT&amp;T&quot;, remark: &quot;&quot;, createdAt: new Date().toISOString() },&#10;  ],&#10;  ips: [&#10;    { id: &quot;i1&quot;, ipAddress: &quot;192.168.1.101&quot;, provider: &quot;AWS&quot;, remark: &quot;US East Proxy&quot;, createdAt: new Date().toISOString() },&#10;    { id: &quot;i2&quot;, ipAddress: &quot;192.168.1.102&quot;, provider: &quot;DigitalOcean&quot;, remark: &quot;Backup Proxy&quot;, createdAt: new Date().toISOString() },&#10;  ],&#10;  slots: [],&#10;  isAuthenticated: false, // Default to false to force login&#10;};&#10;&#10;// --- Context ---&#10;&#10;const StoreContext = createContext&lt;StoreContextType | undefined&gt;(undefined);&#10;&#10;export function StoreProvider({ children }: { children: React.ReactNode }) {&#10;  const [state, setState] = useState&lt;AppState&gt;(() =&gt; {&#10;    const saved = localStorage.getItem(&quot;slot-manager-data&quot;);&#10;    const parsed = saved ? JSON.parse(saved) : INITIAL_STATE;&#10;    return { ...parsed, isAuthenticated: parsed.isAuthenticated ?? false };&#10;  });&#10;&#10;  useEffect(() =&gt; {&#10;    localStorage.setItem(&quot;slot-manager-data&quot;, JSON.stringify(state));&#10;  }, [state]);&#10;&#10;  // Auto-cleanup expired slots logic&#10;  // Runs on mount and every minute to ensure &quot;auto remove without cronjob&quot; feel&#10;  useEffect(() =&gt; {&#10;    const cleanupExpiredSlots = () =&gt; {&#10;      const cutoff = subDays(new Date(), 15);&#10;      &#10;      setState(prev =&gt; {&#10;        const activeSlots = prev.slots.filter(s =&gt; {&#10;          // Keep slot if usedAt is AFTER the cutoff (used within last 15 days)&#10;          return isAfter(parseISO(s.usedAt), cutoff);&#10;        });&#10;&#10;        // Only update state if something changed to avoid re-renders&#10;        if (activeSlots.length !== prev.slots.length) {&#10;          return { ...prev, slots: activeSlots };&#10;        }&#10;        return prev;&#10;      });&#10;    };&#10;&#10;    cleanupExpiredSlots(); // Run immediately on load&#10;    const intervalId = setInterval(cleanupExpiredSlots, 60 * 1000); // Run every minute&#10;&#10;    return () =&gt; clearInterval(intervalId);&#10;  }, []);&#10;&#10;  const login = () =&gt; setState(prev =&gt; ({ ...prev, isAuthenticated: true }));&#10;  const logout = () =&gt; setState(prev =&gt; ({ ...prev, isAuthenticated: false }));&#10;&#10;  const addPhone = (data: Omit&lt;Phone, &quot;id&quot; | &quot;createdAt&quot;&gt;) =&gt; {&#10;    // Require phoneNumber and email&#10;    if (!data.phoneNumber) {&#10;      throw new Error(&quot;Phone number is required&quot;);&#10;    }&#10;    if (!data.email) {&#10;      throw new Error(&quot;Email is required for a phone record&quot;);&#10;    }&#10;&#10;    if (state.phones.some(p =&gt; p.phoneNumber === data.phoneNumber)) {&#10;      throw new Error(&quot;Phone number already exists&quot;);&#10;    }&#10;    const newPhone: Phone = { ...data, id: nanoid(), createdAt: new Date().toISOString() };&#10;    setState(prev =&gt; ({ ...prev, phones: [newPhone, ...prev.phones] }));&#10;  };&#10;&#10;  const updatePhone = (id: string, data: Partial&lt;Phone&gt;) =&gt; {&#10;    setState(prev =&gt; ({&#10;      ...prev,&#10;      phones: prev.phones.map(p =&gt; p.id === id ? { ...p, ...data } : p)&#10;    }));&#10;  };&#10;&#10;  const deletePhone = (id: string) =&gt; {&#10;    setState(prev =&gt; ({&#10;      ...prev,&#10;      phones: prev.phones.filter(p =&gt; p.id !== id),&#10;      slots: prev.slots.filter(s =&gt; s.phoneId !== id) &#10;    }));&#10;  };&#10;&#10;  const addIp = (data: Omit&lt;IP, &quot;id&quot; | &quot;createdAt&quot;&gt;) =&gt; {&#10;    if (state.ips.some(i =&gt; i.ipAddress === data.ipAddress)) {&#10;      throw new Error(&quot;IP Address already exists&quot;);&#10;    }&#10;    const newIp: IP = { ...data, id: nanoid(), createdAt: new Date().toISOString() };&#10;    setState(prev =&gt; ({ ...prev, ips: [newIp, ...prev.ips] }));&#10;  };&#10;&#10;  const updateIp = (id: string, data: Partial&lt;IP&gt;) =&gt; {&#10;    setState(prev =&gt; ({&#10;      ...prev,&#10;      ips: prev.ips.map(i =&gt; i.id === id ? { ...i, ...data } : i)&#10;    }));&#10;  };&#10;&#10;  const deleteIp = (id: string) =&gt; {&#10;    setState(prev =&gt; ({&#10;      ...prev,&#10;      ips: prev.ips.filter(i =&gt; i.id !== id),&#10;      slots: prev.slots.filter(s =&gt; s.ipId !== id)&#10;    }));&#10;  };&#10;&#10;  const getPhoneSlotUsage = (phoneId: string) =&gt; {&#10;    const cutoff = subDays(new Date(), 15);&#10;    return state.slots&#10;      .filter(s =&gt; s.phoneId === phoneId &amp;&amp; isAfter(parseISO(s.usedAt), cutoff))&#10;      .reduce((acc, curr) =&gt; acc + (curr.count || 1), 0);&#10;  };&#10;&#10;  const getIpSlotUsage = (ipId: string) =&gt; {&#10;    const cutoff = subDays(new Date(), 15);&#10;    return state.slots&#10;      .filter(s =&gt; s.ipId === ipId &amp;&amp; isAfter(parseISO(s.usedAt), cutoff))&#10;      .reduce((acc, curr) =&gt; acc + (curr.count || 1), 0);&#10;  };&#10;&#10;  const addSlot = (phoneId: string, ipId: string, count: number, date: Date) =&gt; {&#10;    // STRICT Validation: Prevent if (current usage + new input) &gt; 4&#10;    const currentPhoneUsage = getPhoneSlotUsage(phoneId);&#10;    const currentIpUsage = getIpSlotUsage(ipId);&#10;&#10;    if (currentPhoneUsage + count &gt; 4) {&#10;      return { &#10;        success: false, &#10;        error: `Allocation blocked. Phone would exceed limit (Current: ${currentPhoneUsage}, Adding: ${count}, Limit: 4)` &#10;      };&#10;    }&#10;    if (currentIpUsage + count &gt; 4) {&#10;      return { &#10;        success: false, &#10;        error: `Allocation blocked. IP would exceed limit (Current: ${currentIpUsage}, Adding: ${count}, Limit: 4)` &#10;      };&#10;    }&#10;&#10;    const newSlot: Slot = {&#10;      id: nanoid(),&#10;      phoneId,&#10;      ipId,&#10;      count,&#10;      usedAt: date.toISOString()&#10;    };&#10;&#10;    setState(prev =&gt; ({ ...prev, slots: [newSlot, ...prev.slots] }));&#10;    return { success: true };&#10;  };&#10;&#10;  const deleteSlot = (id: string) =&gt; {&#10;    setState(prev =&gt; ({&#10;      ...prev,&#10;      slots: prev.slots.filter(s =&gt; s.id !== id)&#10;    }));&#10;  };&#10;&#10;  const resetData = () =&gt; {&#10;    // Reset to initial demo data but preserve authentication state (do not auto-login)&#10;    setState(prev =&gt; ({ ...INITIAL_STATE, isAuthenticated: prev.isAuthenticated }));&#10;  };&#10;&#10;  return (&#10;    &lt;StoreContext.Provider value={{&#10;      ...state,&#10;      addPhone,&#10;      updatePhone,&#10;      deletePhone,&#10;      addIp,&#10;      updateIp,&#10;      deleteIp,&#10;      addSlot,&#10;      deleteSlot,&#10;      getPhoneSlotUsage,&#10;      getIpSlotUsage,&#10;      resetData,&#10;      login,&#10;      logout&#10;    }}&gt;&#10;      {children}&#10;    &lt;/StoreContext.Provider&gt;&#10;  );&#10;}&#10;&#10;export function useStore() {&#10;  const context = useContext(StoreContext);&#10;  if (!context) {&#10;    throw new Error(&quot;useStore must be used within a StoreProvider&quot;);&#10;  }&#10;  return context;&#10;}&#10;" />
              <option name="updatedContent" value="import React, { createContext, useContext, useState, useEffect } from &quot;react&quot;;&#10;import { subDays, isAfter, parseISO } from &quot;date-fns&quot;;&#10;import { nanoid } from &quot;nanoid&quot;;&#10;&#10;// --- Types ---&#10;&#10;export interface Phone {&#10;  id: string;&#10;  phoneNumber: string;&#10;  email: string;&#10;  provider?: string;&#10;  remark?: string;&#10;  createdAt: string;&#10;}&#10;&#10;export interface IP {&#10;  id: string;&#10;  ipAddress: string;&#10;  port?: string;&#10;  username?: string;&#10;  password?: string;&#10;  provider?: string;&#10;  remark?: string;&#10;  createdAt: string;&#10;}&#10;&#10;export interface Slot {&#10;  id: string;&#10;  phoneId: string;&#10;  ipId: string;&#10;  count: number;&#10;  usedAt: string;&#10;}&#10;&#10;interface AppState {&#10;  phones: Phone[];&#10;  ips: IP[];&#10;  slots: Slot[];&#10;  isAuthenticated: boolean;&#10;}&#10;&#10;interface StoreContextType extends AppState {&#10;  addPhone: (phone: Omit&lt;Phone, &quot;id&quot; | &quot;createdAt&quot;&gt;) =&gt; void;&#10;  updatePhone: (id: string, phone: Partial&lt;Phone&gt;) =&gt; void;&#10;  deletePhone: (id: string) =&gt; void;&#10;  addIp: (ip: Omit&lt;IP, &quot;id&quot; | &quot;createdAt&quot;&gt;) =&gt; void;&#10;  updateIp: (id: string, ip: Partial&lt;IP&gt;) =&gt; void;&#10;  deleteIp: (id: string) =&gt; void;&#10;  addSlot: (phoneId: string, ipId: string, count: number, date: Date) =&gt; { success: boolean; error?: string };&#10;  deleteSlot: (id: string) =&gt; void;&#10;  getPhoneSlotUsage: (phoneId: string) =&gt; number;&#10;  getIpSlotUsage: (ipId: string) =&gt; number;&#10;  resetData: () =&gt; void;&#10;  login: () =&gt; void;&#10;  logout: () =&gt; void;&#10;}&#10;&#10;// --- Initial Data for Demo ---&#10;&#10;const INITIAL_STATE: AppState = {&#10;  phones: [&#10;    { id: &quot;p1&quot;, phoneNumber: &quot;+15550101&quot;, email: &quot;demo1@example.com&quot;, provider: &quot;Verizon&quot;, remark: &quot;Primary demo phone&quot;, createdAt: new Date().toISOString() },&#10;    { id: &quot;p2&quot;, phoneNumber: &quot;+15550102&quot;, email: &quot;demo2@example.com&quot;, provider: &quot;AT&amp;T&quot;, remark: &quot;&quot;, createdAt: new Date().toISOString() },&#10;  ],&#10;  ips: [&#10;    { id: &quot;i1&quot;, ipAddress: &quot;192.168.1.101&quot;, provider: &quot;AWS&quot;, remark: &quot;US East Proxy&quot;, createdAt: new Date().toISOString() },&#10;    { id: &quot;i2&quot;, ipAddress: &quot;192.168.1.102&quot;, provider: &quot;DigitalOcean&quot;, remark: &quot;Backup Proxy&quot;, createdAt: new Date().toISOString() },&#10;  ],&#10;  slots: [],&#10;  isAuthenticated: false, // Default to false to force login&#10;};&#10;&#10;// --- Context ---&#10;&#10;const StoreContext = createContext&lt;StoreContextType | undefined&gt;(undefined);&#10;&#10;export function StoreProvider({ children }: { children: React.ReactNode }) {&#10;  const [state, setState] = useState&lt;AppState&gt;(() =&gt; {&#10;    const saved = localStorage.getItem(&quot;slot-manager-data&quot;);&#10;    const parsed = saved ? JSON.parse(saved) : INITIAL_STATE;&#10;    return { ...parsed, isAuthenticated: parsed.isAuthenticated ?? false };&#10;  });&#10;&#10;  useEffect(() =&gt; {&#10;    localStorage.setItem(&quot;slot-manager-data&quot;, JSON.stringify(state));&#10;  }, [state]);&#10;&#10;  // Auto-cleanup expired slots logic&#10;  // Runs on mount and every minute to ensure &quot;auto remove without cronjob&quot; feel&#10;  useEffect(() =&gt; {&#10;    const cleanupExpiredSlots = () =&gt; {&#10;      const cutoff = subDays(new Date(), 15);&#10;      &#10;      setState(prev =&gt; {&#10;        const activeSlots = prev.slots.filter(s =&gt; {&#10;          // Keep slot if usedAt is AFTER the cutoff (used within last 15 days)&#10;          return isAfter(parseISO(s.usedAt), cutoff);&#10;        });&#10;&#10;        // Only update state if something changed to avoid re-renders&#10;        if (activeSlots.length !== prev.slots.length) {&#10;          return { ...prev, slots: activeSlots };&#10;        }&#10;        return prev;&#10;      });&#10;    };&#10;&#10;    cleanupExpiredSlots(); // Run immediately on load&#10;    const intervalId = setInterval(cleanupExpiredSlots, 60 * 1000); // Run every minute&#10;&#10;    return () =&gt; clearInterval(intervalId);&#10;  }, []);&#10;&#10;  const login = () =&gt; setState(prev =&gt; ({ ...prev, isAuthenticated: true }));&#10;  const logout = () =&gt; setState(prev =&gt; ({ ...prev, isAuthenticated: false }));&#10;&#10;  const addPhone = (data: Omit&lt;Phone, &quot;id&quot; | &quot;createdAt&quot;&gt;) =&gt; {&#10;    // Require phoneNumber&#10;    if (!data.phoneNumber) {&#10;      throw new Error(&quot;Phone number is required&quot;);&#10;    }&#10;&#10;    if (state.phones.some(p =&gt; p.phoneNumber === data.phoneNumber)) {&#10;      throw new Error(&quot;Phone number already exists&quot;);&#10;    }&#10;    const newPhone: Phone = { ...data, id: nanoid(), createdAt: new Date().toISOString() };&#10;    setState(prev =&gt; ({ ...prev, phones: [newPhone, ...prev.phones] }));&#10;  };&#10;&#10;  const updatePhone = (id: string, data: Partial&lt;Phone&gt;) =&gt; {&#10;    setState(prev =&gt; ({&#10;      ...prev,&#10;      phones: prev.phones.map(p =&gt; p.id === id ? { ...p, ...data } : p)&#10;    }));&#10;  };&#10;&#10;  const deletePhone = (id: string) =&gt; {&#10;    setState(prev =&gt; ({&#10;      ...prev,&#10;      phones: prev.phones.filter(p =&gt; p.id !== id),&#10;      slots: prev.slots.filter(s =&gt; s.phoneId !== id) &#10;    }));&#10;  };&#10;&#10;  const addIp = (data: Omit&lt;IP, &quot;id&quot; | &quot;createdAt&quot;&gt;) =&gt; {&#10;    if (state.ips.some(i =&gt; i.ipAddress === data.ipAddress)) {&#10;      throw new Error(&quot;IP Address already exists&quot;);&#10;    }&#10;    const newIp: IP = { ...data, id: nanoid(), createdAt: new Date().toISOString() };&#10;    setState(prev =&gt; ({ ...prev, ips: [newIp, ...prev.ips] }));&#10;  };&#10;&#10;  const updateIp = (id: string, data: Partial&lt;IP&gt;) =&gt; {&#10;    setState(prev =&gt; ({&#10;      ...prev,&#10;      ips: prev.ips.map(i =&gt; i.id === id ? { ...i, ...data } : i)&#10;    }));&#10;  };&#10;&#10;  const deleteIp = (id: string) =&gt; {&#10;    setState(prev =&gt; ({&#10;      ...prev,&#10;      ips: prev.ips.filter(i =&gt; i.id !== id),&#10;      slots: prev.slots.filter(s =&gt; s.ipId !== id)&#10;    }));&#10;  };&#10;&#10;  const getPhoneSlotUsage = (phoneId: string) =&gt; {&#10;    const cutoff = subDays(new Date(), 15);&#10;    return state.slots&#10;      .filter(s =&gt; s.phoneId === phoneId &amp;&amp; isAfter(parseISO(s.usedAt), cutoff))&#10;      .reduce((acc, curr) =&gt; acc + (curr.count || 1), 0);&#10;  };&#10;&#10;  const getIpSlotUsage = (ipId: string) =&gt; {&#10;    const cutoff = subDays(new Date(), 15);&#10;    return state.slots&#10;      .filter(s =&gt; s.ipId === ipId &amp;&amp; isAfter(parseISO(s.usedAt), cutoff))&#10;      .reduce((acc, curr) =&gt; acc + (curr.count || 1), 0);&#10;  };&#10;&#10;  const addSlot = (phoneId: string, ipId: string, count: number, date: Date) =&gt; {&#10;    // STRICT Validation: Prevent if (current usage + new input) &gt; 4&#10;    const currentPhoneUsage = getPhoneSlotUsage(phoneId);&#10;    const currentIpUsage = getIpSlotUsage(ipId);&#10;&#10;    if (currentPhoneUsage + count &gt; 4) {&#10;      return { &#10;        success: false, &#10;        error: `Allocation blocked. Phone would exceed limit (Current: ${currentPhoneUsage}, Adding: ${count}, Limit: 4)` &#10;      };&#10;    }&#10;    if (currentIpUsage + count &gt; 4) {&#10;      return { &#10;        success: false, &#10;        error: `Allocation blocked. IP would exceed limit (Current: ${currentIpUsage}, Adding: ${count}, Limit: 4)` &#10;      };&#10;    }&#10;&#10;    const newSlot: Slot = {&#10;      id: nanoid(),&#10;      phoneId,&#10;      ipId,&#10;      count,&#10;      usedAt: date.toISOString()&#10;    };&#10;&#10;    setState(prev =&gt; ({ ...prev, slots: [newSlot, ...prev.slots] }));&#10;    return { success: true };&#10;  };&#10;&#10;  const deleteSlot = (id: string) =&gt; {&#10;    setState(prev =&gt; ({&#10;      ...prev,&#10;      slots: prev.slots.filter(s =&gt; s.id !== id)&#10;    }));&#10;  };&#10;&#10;  const resetData = () =&gt; {&#10;    // Reset to initial demo data but preserve authentication state (do not auto-login)&#10;    setState(prev =&gt; ({ ...INITIAL_STATE, isAuthenticated: prev.isAuthenticated }));&#10;  };&#10;&#10;  return (&#10;    &lt;StoreContext.Provider value={{&#10;      ...state,&#10;      addPhone,&#10;      updatePhone,&#10;      deletePhone,&#10;      addIp,&#10;      updateIp,&#10;      deleteIp,&#10;      addSlot,&#10;      deleteSlot,&#10;      getPhoneSlotUsage,&#10;      getIpSlotUsage,&#10;      resetData,&#10;      login,&#10;      logout&#10;    }}&gt;&#10;      {children}&#10;    &lt;/StoreContext.Provider&gt;&#10;  );&#10;}&#10;&#10;export function useStore() {&#10;  const context = useContext(StoreContext);&#10;  if (!context) {&#10;    throw new Error(&quot;useStore must be used within a StoreProvider&quot;);&#10;  }&#10;  return context;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>